#include <bits/stdc++.h>
using namespace std;

struct Graph{
	int V;
	map<int, vector<int>> adj_map;
	vector<vector<int>> edges;
	Graph(vector<vector<int>> edges) : V(1), edges(edges){
		for (vector<int> edge : edges){
			int src = edge[0], dest = edge[1];
			if (adj_map.find(src) == adj_map.end()){
				adj_map.insert({src, {dest} });
				V++;
				if (adj_map.find(dest) == adj_map.end()){
					adj_map.insert({dest, {} });
					V++;
				}
			} else
				adj_map[src].push_back(dest);
		}
	}

	vector<int> getRedundantEdge(){
		bool visited[V];
		memset(visited, false, V);
		vector<vector<int>> res;
		for (int node = 0; node < V; node++){
			DFS(node, res, visited);
		}
		if (res.size() == 1)
			return res[0];
		return findLastRedundant(res);
	}
	vector<int> findLastRedundant(vector<vector<int>> res){
		vector<int> last_redundant;
		for (int i = V-1; i >=0; i--){
			vector<int> edge = edges[i];
			if (find(res.begin(), res.end(), edge) != res.end())
				return edge;
		}
		return {};
	}
private:
	void DFS(int node, vector<vector<int>>& res, bool* visited){
		visited[node] = true;	
		vector<int> neighbors = adj_map[node];
		for (int neighbor : neighbors){
			if (!visited[neighbor])
				DFS(neighbor, res, visited);
			else
				res.push_back( {node, neighbor} );
		}
	}
};

class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
		Graph g(edges);
		return g.getRedundantEdge();
    }
};

int main(){
	Solution sol;
	// vector<vector<int>> edges = { {1,2}, {1,3}, {2,3} }; // (2,3)
	vector<vector<int>> edges = {{1,2},{2,3},{3,4},{1,4},{1,5}}; // (1,4)
	vector<int> res = sol.findRedundantConnection(edges);
	printf("(%i,%i)\n", res[0], res[1]);

}
